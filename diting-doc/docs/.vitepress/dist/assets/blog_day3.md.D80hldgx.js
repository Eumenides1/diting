import{_ as i,c as a,a0 as n,o as l}from"./chunks/framework.Cb6JQtk2.js";const o=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blog/day3.md","filePath":"blog/day3.md"}'),t={name:"blog/day3.md"};function h(p,s,k,e,r,E){return l(),a("div",null,s[0]||(s[0]=[n(`<blockquote><p>代码仓库：<a href="https://github.com/Eumenides1/diting" target="_blank" rel="noreferrer">https://github.com/Eumenides1/diting</a></p></blockquote><p>在前面的开发中，我们已经基本完成了谛听的加载器部分，实现了用户可以通过自定义配置的方式，选择不同类型的敏感词库加载器，加载自己业务的敏感词；完成敏感词加载之后，今天我们来继续，敏感词识别的核心 - <strong>Aho-Corasick 自动机（AC 自动机）</strong>。</p><h2 id="前置知识-trie树" tabindex="-1">前置知识 - Trie树 <a class="header-anchor" href="#前置知识-trie树" aria-label="Permalink to &quot;前置知识 - Trie树&quot;">​</a></h2><p>了解 <strong>Trie</strong> 是学习 <strong>DFA</strong> 和 <strong>AC 自动机</strong> 的重要基础，因为这三者之间存在递进关系。Trie 不仅是 DFA 和 AC 自动机的核心数据结构之一，还能帮助我们理解更高阶的自动化匹配算法中的设计思想。</p><h3 id="trie-是个啥" tabindex="-1"><strong>Trie 是个啥？</strong> <a class="header-anchor" href="#trie-是个啥" aria-label="Permalink to &quot;**Trie 是个啥？**&quot;">​</a></h3><p>在计算机科学中，<strong>Trie</strong> 是一种树形数据结构，用于存储字符串（通常是单词）。它的名称来源于“retrieval”（检索），但一般念作“try”，因为英文里更好发音。</p><p><strong>核心特点</strong></p><ul><li><strong>逐字符存储</strong>：Trie 将字符串拆分成字符，逐个字符作为树的节点。</li><li><strong>路径唯一性</strong>：从根节点到某一节点的路径代表某个字符串的前缀。</li><li><strong>高效检索</strong>：插入、查找、删除的时间复杂度与字符串的长度成线性关系，通常是  O(L) ，其中  L  是字符串长度。</li></ul><p>想象一下，你是一个图书管理员，负责管理一本超大的字典，里面的单词多到让你头大。你的任务是：有人报个单词，比如“cat”，你得立刻告诉他这个单词在不在字典里，或者是否有其他单词以“ca”开头（比如“car”、“cake”）。传统的方法是翻遍字典一页页找，这效率可不怎么样。于是你灵机一动，发明了一个超级聪明的系统，这个系统的名字叫做 <strong>Trie</strong>！（读作 “try”，就是让你努力试试看！）</p><p>Trie（也叫前缀树）就像是一本超能分裂的魔法书。它不会按照传统的方法一页页地翻，而是直接把单词拆开成一个个字母，每个字母都是一条分支。它就像一棵树，树干是空的，树枝是字母，树叶是完整的单词。你在找单词时，走着字母的路径，就像顺着树枝爬，走到头，看看有没有结果。Trie 本质上是一个<strong>有限状态机</strong>（Finite State Machine, FSM）的雏形。每个节点都表示某个“状态”，而每条边是字符的“转移条件”。例如，在一个 Trie 中，你从 c -&gt; a -&gt; t 这条路径，就意味着通过状态转移形成了单词 “cat”。</p><p>我们举个栗子🌰：</p><p>假设你有以下单词：<code>cat、car、cake、dog、door</code>,普通方法：你得先从头到尾查“cat”，然后再从头到尾查“car”，单词一多，累得够呛。</p><p>Trie 方法：你说单词是字母堆出来的，对吧？Trie 直接用一棵树，把相同的字母合并共享：</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root((root))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root --&gt; c</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root --&gt; d</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c --&gt; a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    d --&gt; o</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; t</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; r</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; k</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    o --&gt; g</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    o --&gt; o2[&quot;r&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    k --&gt; e</span></span></code></pre></div><p>看这棵字母树，单词共享了相同的前缀路径：</p><ul><li><p>“cat” 和 “car” 共用 <code>c -&gt; a</code>。</p></li><li><p>“cake” 又和“cat”和“car”共用了前两步，然后拐向了自己的分支。</p></li><li><p>“dog” 和 “door” 一样，到了 <code>d -&gt; o</code> 后才分开。</p></li></ul><p>这么一搞，你想找“ca”开头的单词时，只要走到“ca”这一层，看它的子节点就知道下面有没有单词了，效率倍儿高！👀</p><h3 id="trie-的性格特征" tabindex="-1"><strong>Trie 的性格特征</strong> <a class="header-anchor" href="#trie-的性格特征" aria-label="Permalink to &quot;**Trie 的性格特征**&quot;">​</a></h3><ol><li><p><strong>爱分享</strong>：相同的前缀字母只存一次，节省了很多空间。</p></li><li><p><strong>不啰嗦</strong>：只存字母的路径，完整单词结束的地方会打个标记（比如一个特殊的 isWord=true）。</p></li><li><p><strong>速度达人</strong>：查找单词时只需要按字母一路走，最坏情况是走完单词的长度。</p></li></ol><h3 id="用-trie-的场景" tabindex="-1"><strong>用 Trie 的场景</strong> <a class="header-anchor" href="#用-trie-的场景" aria-label="Permalink to &quot;**用 Trie 的场景**&quot;">​</a></h3><p>Trie 是个干活小能手，在以下场景下非常擅长：</p><ul><li><strong>字典查词</strong>：比如找一个单词是不是存在，或者找以某个前缀开头的所有单词。</li><li><strong>自动补全</strong>：搜索引擎的自动补全功能，比如你敲了“ca”，它立刻提示“cat”、“car”、“cake”。</li><li><strong>敏感词过滤</strong>：快速找到某段文字里有没有包含敏感词。</li><li><strong>拼写检查</strong>：比如你输入了“caar”，它可以告诉你“car”是不是你想找的单词。</li></ul><h3 id="trie-的小缺点" tabindex="-1"><strong>Trie 的小缺点</strong> <a class="header-anchor" href="#trie-的小缺点" aria-label="Permalink to &quot;**Trie 的小缺点**&quot;">​</a></h3><p>当然啦，Trie 也不是完美的，有点“贪心”的性格——</p><ul><li><strong>空间吃得多</strong>：虽然共享了前缀，但存储每个字母和节点也需要额外的空间。如果单词特别多，Trie 可能会长成一棵巨型的魔法树。</li><li><strong>冷门字母也要存</strong>：就算字母出现很少，比如 “x” 或 “q”，它也得为这些罕见路径预留节点。</li></ul><hr><h2 id="确定性有限自动机-dfa" tabindex="-1"><strong>确定性有限自动机（DFA）</strong> <a class="header-anchor" href="#确定性有限自动机-dfa" aria-label="Permalink to &quot;**确定性有限自动机（DFA）**&quot;">​</a></h2><p>要真正理解 AC 自动机的强大之处，我们需要回顾一下它的“前身”——<strong>确定性有限自动机（Deterministic Finite Automaton，简称 DFA）</strong> ，并探讨它们之间的演变过程。让我们一起开启这段“自动机家族史”的旅程，看看 DFA 如何一步步演变成如今的 AC 自动机。</p><h3 id="dfa-的基本概念" tabindex="-1"><strong>DFA 的基本概念</strong> <a class="header-anchor" href="#dfa-的基本概念" aria-label="Permalink to &quot;**DFA 的基本概念**&quot;">​</a></h3><p><strong>确定性有限自动机（DFA）</strong> 是一种数学模型，用于识别和处理特定的字符串模式。它由以下几个部分组成：</p><ul><li><strong>状态（States）</strong> ：表示自动机的不同“阶段”。</li><li><strong>输入符号（Input Symbols）</strong> ：自动机处理的字符集。</li><li><strong>转移函数（Transition Function）</strong> ：定义了自动机如何从一个状态转移到另一个状态，基于当前输入符号。</li><li><strong>起始状态（Start State）</strong> ：自动机开始处理输入的初始状态。</li><li><strong>接受状态（Accept States）</strong> ：表示自动机成功识别到模式的状态。</li></ul><h3 id="dfa-的工作原理" tabindex="-1"><strong>DFA 的工作原理</strong> <a class="header-anchor" href="#dfa-的工作原理" aria-label="Permalink to &quot;**DFA 的工作原理**&quot;">​</a></h3><p>让我们通过一个简单的例子来理解 DFA 的工作原理。 假设我们要构建一个 DFA，用于识别字符串中是否包含子字符串“ABC”。</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stateDiagram-v2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [*] --&gt; S0 : 开始</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S0 --&gt; S1 : 输入 &quot;A&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S0 --&gt; S0 : 其他输入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S1 --&gt; S2 : 输入 &quot;B&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S1 --&gt; S1 : 输入 &quot;A&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S1 --&gt; S0 : 其他输入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S2 --&gt; S3 : 输入 &quot;C&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S2 --&gt; S1 : 输入 &quot;A&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S2 --&gt; S0 : 其他输入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S3 --&gt; S3 : 任意输入</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    S3 : 接受状态</span></span></code></pre></div><ol><li><p><strong>状态设计</strong>：</p><ul><li><strong>S0</strong>：初始状态，尚未匹配任何字符。</li><li><strong>S1</strong>：已匹配到“A”。</li><li><strong>S2</strong>：已匹配到“AB”。</li><li><strong>S3</strong>：已匹配到“ABC”（接受状态）。</li></ul></li><li><p><strong>转移函数</strong>：</p><ul><li>在 <strong>S0</strong>，输入“A”转移到 <strong>S1</strong>，其他输入保持在 <strong>S0</strong>。</li><li>在 <strong>S1</strong>，输入“B”转移到 <strong>S2</strong>，输入“A”保持在 <strong>S1</strong>，其他输入回到 <strong>S0</strong>。</li><li>在 <strong>S2</strong>，输入“C”转移到 <strong>S3</strong>，输入“A”转移到 <strong>S1</strong>，其他输入回到 <strong>S0</strong>。</li><li>在 <strong>S3</strong>，保持在 <strong>S3</strong>（接受状态）。</li></ul></li><li><p><strong>匹配过程</strong>：</p></li></ol><ul><li>读取输入字符串中的每个字符，按照转移函数更新状态。</li><li>如果最终状态为接受状态 <strong>S3</strong>，则表示字符串中包含“ABC”。</li></ul><h3 id="dfa-的优缺点" tabindex="-1"><strong>DFA 的优缺点</strong> <a class="header-anchor" href="#dfa-的优缺点" aria-label="Permalink to &quot;**DFA 的优缺点**&quot;">​</a></h3><p><strong>优点</strong>：</p><ul><li><strong>高效性</strong>：DFA 的匹配过程是线性的，时间复杂度为 O(n)，其中 n 是输入字符串的长度。</li><li><strong>确定性</strong>：每个状态对每个输入符号有唯一的转移，避免了不确定性和回溯。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>状态爆炸</strong>：对于复杂的模式或多个模式，DFA 的状态数量可能急剧增加，导致内存消耗大。</li><li><strong>扩展性差</strong>：在处理多个模式时，需要构建多个 DFA，难以高效地管理和匹配。</li></ul><h2 id="aho-corasick-自动机" tabindex="-1"><strong>Aho-Corasick 自动机</strong> <a class="header-anchor" href="#aho-corasick-自动机" aria-label="Permalink to &quot;**Aho-Corasick 自动机**&quot;">​</a></h2><p>传统的 DFA 适用于单一模式的匹配。然而，在实际应用中，我们常常需要同时匹配多个模式。例如，在敏感词识别中，我们需要在文本中同时查找“坏蛋”、“贪婪”、“诚信”等多个敏感词。使用单个 DFA 分别匹配每个模式，不仅效率低下，还增加了系统的复杂性。 <strong>Aho-Corasick 自动机的诞生</strong></p><p>为了解决多模式匹配的问题，<strong>Alfred V. Aho</strong> 和 <strong>Margaret J. Corasick</strong> 于 1975 年提出了 <strong>Aho-Corasick 自动机</strong>。它是一种能够在一个文本中同时搜索多个关键词的高效算法，结合了 DFA 和 Trie 树的优势，克服了传统 DFA 在多模式匹配中的不足。</p><h3 id="ac-自动机的发展历程" tabindex="-1"><strong>AC 自动机的发展历程</strong> <a class="header-anchor" href="#ac-自动机的发展历程" aria-label="Permalink to &quot;**AC 自动机的发展历程**&quot;">​</a></h3><p>AC 自动机诞生于上世纪七十年代，那个时候计算资源有限，处理效率成为算法设计的核心考量。Aho 和 Corasick 提出的这一算法，凭借其线性时间复杂度（与文本长度和关键词数量成正比），迅速在多个领域得到了广泛应用，包括文本搜索、网络安全、自然语言处理等。</p><p>AC 自动机不仅仅能找到关键词，它还能告诉你这些关键词出现的位置，以及它们是如何相互交织的。这就像是一个聪明的侦探，能够在复杂的情节中迅速找出关键线索。</p><p>随着计算能力的提升和应用场景的扩展，AC 自动机不断演化，适应了现代敏感词识别的需求。如今，它不仅在静态文本处理中表现出色，还被应用于实时数据流、日志分析等动态场景中。</p><h3 id="ac-自动机是如何运作的" tabindex="-1"><strong>AC 自动机是如何运作的？</strong> <a class="header-anchor" href="#ac-自动机是如何运作的" aria-label="Permalink to &quot;**AC 自动机是如何运作的？**&quot;">​</a></h3><p>要理解 AC 自动机的工作原理，我们可以将其分解为几个关键步骤：构建 Trie 树、构建失败指针，以及进行匹配。让我们一步一步来揭开这个“超级英雄”的神秘面纱。</p><h4 id="构建-trie-树" tabindex="-1"><strong>构建 Trie 树</strong> <a class="header-anchor" href="#构建-trie-树" aria-label="Permalink to &quot;**构建 Trie 树**&quot;">​</a></h4><p><strong>Trie 树</strong> 是 AC 自动机的基础，用于存储所有模式串（敏感词）。每个节点代表一个字符，路径上的字符组合起来就形成了一个敏感词。</p><p>我们依然使用我们在Trie 树部分使用的例子：</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root((root))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root --&gt; c</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root --&gt; d</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c --&gt; a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    d --&gt; o</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; t</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; r</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; k</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    o --&gt; g</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    o --&gt; o2[&quot;r&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    k --&gt; e</span></span></code></pre></div><h4 id="构建失败指针" tabindex="-1"><strong>构建失败指针</strong> <a class="header-anchor" href="#构建失败指针" aria-label="Permalink to &quot;**构建失败指针**&quot;">​</a></h4><p>构建 <strong>失败指针</strong> 是 AC 自动机的核心。失败指针的作用是，当匹配失败时，能够跳转到其他可能的匹配路径，而不需要从头重新开始匹配。</p><p><strong>失败指针规则</strong>：</p><ol><li>根节点的直接子节点（c 和 d）的失败指针指向根节点。</li><li>每个节点的失败指针通过以下方式构建： <ul><li>如果当前节点的字符无法匹配，则跳转到当前节点的父节点的失败指针所指向的节点。</li><li>如果没有匹配的节点，失败指针指向根节点。</li></ul></li></ol><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root((root))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root --&gt; c</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root --&gt; d</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c --&gt; a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    d --&gt; o</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; t</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; r</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a --&gt; k</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    o --&gt; g</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    o --&gt; r</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    k --&gt; e</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 添加失败指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c -.-&gt; root</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    d -.-&gt; root</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a -.-&gt; root</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    t -.-&gt; root</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    r -.-&gt; root</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    k -.-&gt; root</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    g -.-&gt; root</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    e -.-&gt; root</span></span></code></pre></div><ul><li>节点 c 和 d 的失败指针直接指向根节点。</li><li>节点 o2 的失败指针指向共享的 o 节点，因为 o 是其匹配的父路径。</li></ul><h4 id="进行匹配" tabindex="-1"><strong>进行匹配</strong> <a class="header-anchor" href="#进行匹配" aria-label="Permalink to &quot;**进行匹配**&quot;">​</a></h4><p>匹配过程是 AC 自动机的核心应用场景。通过 Trie 树和失败指针，AC 自动机能够快速完成多模式匹配。</p><p>假设我们匹配文本：&quot;cattodoorcake&quot;</p><p><strong>匹配过程</strong>：</p><ol><li><p><strong>开始匹配</strong>：</p><ul><li>从根节点 root 开始，扫描文本的第一个字符 c。</li><li>匹配到节点 c，继续扫描下一个字符。</li></ul></li><li><p><strong>匹配</strong> cat：</p><ul><li>第二个字符 a，匹配到节点 a。</li><li>第三个字符 t，匹配到节点 t。</li><li>到达 t 节点时，完成 cat 的匹配。</li></ul></li><li><p><strong>处理</strong> to <strong>的失败</strong>：</p><ul><li>下一个字符是 t，但 t 没有从 root 开始的路径。</li><li><strong>失败指针生效</strong>：回到根节点 root，继续匹配下一个字符 o。</li><li>o 同样没有从根节点匹配的路径，失败指针继续指向根节点。</li></ul></li><li><p><strong>匹配</strong> door：</p><ul><li>扫描到字符 d，匹配到节点 d。</li><li>下一个字符 o，匹配到节点 o。</li><li>下一个字符 o，再次匹配到o节点。</li><li>最后一个字符 r，匹配到节点 r，完成 door 的匹配。</li></ul></li><li><p><strong>处理</strong> ca <strong>后的失败</strong>：</p><ul><li>扫描到字符 c，匹配到节点 c。</li><li>下一个字符 a，匹配到节点 a。</li><li>接下来的字符是 k，匹配到节点 k。</li><li>下一个字符是 e，匹配到节点 e，完成 cake 的匹配。</li></ul></li></ol><h3 id="ac-自动机的优势" tabindex="-1"><strong>AC 自动机的优势</strong> <a class="header-anchor" href="#ac-自动机的优势" aria-label="Permalink to &quot;**AC 自动机的优势**&quot;">​</a></h3><ul><li><p><strong>线性时间复杂度</strong>：AC 自动机的时间复杂度为 <strong>O(n + m + z)</strong> ，其中：</p><ul><li><strong>n</strong> 是文本的长度</li><li><strong>m</strong> 是所有敏感词长度的总和</li><li><strong>z</strong> 是匹配到的敏感词数量</li><li><strong>一次扫描</strong>：文本只需扫描一次，极大提高了匹配效率。</li></ul></li><li><p><strong>多模式匹配</strong>：</p><ul><li>无需为每个敏感词构建独立的 DFA，AC 自动机能够同时处理多个敏感词，避免了多次扫描文本的开销。</li><li>前缀树的优势，前缀共享，提高内存利用效率。</li></ul></li></ul><hr><h2 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h2><p>终于到了激动人心的代码时间，经过上述对于 AC 自动机相关知识的了解，我们开始在谛听中，实现我们的 AC 自动机，并完成敏感词匹配相关的功能。</p><h3 id="acnode的定义" tabindex="-1">ACNode的定义 <a class="header-anchor" href="#acnode的定义" aria-label="Permalink to &quot;ACNode的定义&quot;">​</a></h3><p>ACNode 是构建 Trie 树和失败指针的基本单位，也是自动机的一个最小节点单位，我们需要他能够：</p><ol><li>存储字符节点的子节点。</li><li>有一个失败指针。</li><li>标记当前节点是不是已经是敏感词结尾了。</li><li>存储已经匹配到的节点字符。</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ACNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Character</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ACNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashMap&lt;&gt;(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子节点映射</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ACNode failure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 失败指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是否是敏感词结尾</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Set&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashSet&lt;&gt;(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前节点匹配到的敏感词集合</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ACNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>假设敏感词为：<code>[&quot;cat&quot;, &quot;car&quot;, &quot;cake&quot;]</code>，构造的 Trie 树部分节点如下：</p><ul><li>根节点 root： <ul><li>children 包含 c。</li></ul></li><li>节点 c： <ul><li>children 包含 a。</li><li>failure 指向 root。</li></ul></li><li>节点 a： <ul><li>children 包含 t, r, 和 k。</li><li>failure 指向 root。</li></ul></li><li>节点 t： <ul><li>isEnd = true。</li><li>output 包含 &quot;cat&quot;。</li><li>failure 指向 root。</li></ul></li></ul><hr><h3 id="构造-ac-自动机" tabindex="-1"><strong>构造 AC 自动机</strong> <a class="header-anchor" href="#构造-ac-自动机" aria-label="Permalink to &quot;**构造 AC 自动机**&quot;">​</a></h3><p>有了 ACNode 节点之后呢，我来开始构造我们的 AC 自动机，首先我们需要构造一颗 Trie 树。</p><p><strong>基本逻辑也很简单：</strong> 每次从根节点 root 开始，将敏感词逐字符插入。如果字符不存在对应的子节点，则创建一个新的 ACNode；如果是敏感词的结尾，标记 isEnd = true，并将该词添加到 output 中。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildTrie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keywords) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (String keyword </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keywords) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ACNode node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keyword.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computeIfAbsent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c, k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ACNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        node.isEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        node.output.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(keyword);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>构造完成基础的 Trie 之后，我们开到 AC 自动机构造的重点，为每个节点构造失败指针。</p><p>其实构造失败指针的逻辑，也没有那么的复杂。</p><p>失败指针的目的是：<strong>当我们匹配失败时，可以快速跳到另一个可能的匹配路径，而不用从头开始重新匹配。</strong> 构建失败指针可以看作是：<strong>为每个节点找到一个“备胎”节点，当正匹配路径失效时，就去找这个备胎继续匹配。</strong></p><p><strong>详细逻辑说明</strong></p><ol><li><strong>初始化根节点的子节点</strong>： <ul><li>根节点的子节点（直接连接到 root 的节点，比如 c 和 d）的失败指针直接指向 root。</li><li>为什么？因为它们没有更深的前缀可供参考，如果失败了只能回到根节点重新开始。</li></ul></li><li><strong>递归设置失败指针</strong>： <ul><li>对于每个节点（比如 a），它的失败指针由<strong>父节点的失败指针</strong>来决定。</li><li>如果父节点的失败指针指向的节点中存在当前字符 c，那么当前节点的失败指针指向这个匹配的节点。</li><li>如果不存在，失败指针直接回到根节点。</li></ul></li><li><strong>合并输出</strong>： <ul><li>当前节点的输出集合需要包含<strong>自己匹配的敏感词</strong>和<strong>失败指针所指节点的敏感词</strong>。</li><li>这样即使跳到了失败指针指向的节点，也不会遗漏匹配到的敏感词。</li></ul></li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildFailurePointers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Queue&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ACNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; queue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedList&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 初始化根节点的直接子节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ACNode child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        child.failure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ACNode current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">poll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Map.Entry&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Character</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ACNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; entry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">entrySet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ACNode child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 设置 failure 指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ACNode failure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.failure;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (failure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">failure.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">containsKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                failure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> failure.failure;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (failure.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">containsKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> failure.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                child.failure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> failure.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                child.failure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 合并失败节点的输出</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            child.output.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child.failure.output);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 将子节点加入队列</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>类比解释：失败指针就像备用路线</strong></p><p>假设你要去商场，而商场有几条路径（Trie 树上的不同路径）。如果你走的路突然被封了（匹配失败），你需要通过导航（失败指针）找到一条备用路线。</p><ol><li>如果你是从家（root）出发，刚开始选了一条主干道（比如 c），但是没通，你就直接回家（root）重新找别的路。</li><li>如果你走到了某个中间位置，比如 ca（a 节点），但是发现接下来的路（t）走不通，这时候你看 ca 的备选路线（父节点 c 的失败指针指向的节点里有没有 a），如果有，直接跳到那里继续走。</li><li>如果实在没有备选路线，只能回到家（root）。</li></ol><p><strong>最终失败指针构建后的结果</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(root)</span></span>
<span class="line"><span>  ├── c --&gt; (失败: root)</span></span>
<span class="line"><span>  │    └── a --&gt; (失败: root)</span></span>
<span class="line"><span>  │         ├── t (失败: root, 输出: [&quot;cat&quot;])</span></span>
<span class="line"><span>  │         └── r (失败: root, 输出: [&quot;car&quot;])</span></span>
<span class="line"><span>  └── d --&gt; (失败: root)</span></span>
<span class="line"><span>       └── o --&gt; (失败: root)</span></span>
<span class="line"><span>            ├── g (失败: root, 输出: [&quot;dog&quot;])</span></span>
<span class="line"><span>            └── o --&gt; (失败: root)</span></span>
<span class="line"><span>                 └── r (失败: root, 输出: [&quot;door&quot;])</span></span></code></pre></div><h3 id="提供敏感词发现的方法" tabindex="-1">提供敏感词发现的方法 <a class="header-anchor" href="#提供敏感词发现的方法" aria-label="Permalink to &quot;提供敏感词发现的方法&quot;">​</a></h3><p>根据我们构造出的 AC 自动机，就能快速的实现一个敏感词发现的功能。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findSensitiveWords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String text) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sensitiveWords </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ACNode currentNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] chars </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chars) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (currentNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentNode.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">containsKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            currentNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentNode.failure; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 失败跳转</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        currentNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentNode.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c, root);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentNode.output.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            sensitiveWords.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentNode.output);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sensitiveWords;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>从 root 开始，逐字符扫描目标文本。</li><li>如果字符匹配，进入下一个节点；如果不匹配，通过失败指针跳转。</li><li>如果当前节点有敏感词（output 非空），将其加入结果集合。</li></ul><h3 id="功能测试" tabindex="-1">功能测试 <a class="header-anchor" href="#功能测试" aria-label="Permalink to &quot;功能测试&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; keywords </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;car&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cake&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dog&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;door&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ACTrie acTrie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ACTrie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(keywords);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;caketcatcar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> acTrie.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findSensitiveWords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;匹配到的敏感词：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：匹配到的敏感词：[cake, cat, car]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>从 DFA 到 AC 自动机，敏感词识别技术经历了一次重要的演变。<strong>确定性有限自动机（DFA）</strong> 在单模式匹配中表现出色，但在多模式匹配中存在状态爆炸和扩展性差的问题。<strong>Aho-Corasick 自动机（AC 自动机）</strong> 通过引入 Trie 树和失败指针，成功解决了多模式匹配的效率和灵活性问题，成为敏感词识别领域的“超级英雄”。</p><p><strong>AC 自动机</strong> 以其高效的线性时间复杂度、强大的多模式匹配能力和灵活的扩展性，成为现代敏感词识别系统的核心组件。通过合理的设计和优化，结合其他先进的算法和技术，AC 自动机能够为您的应用提供稳定、快速、准确的敏感词检测与替换功能，守护您的内容合规与用户体验。</p><p><strong>关键要点</strong>：</p><p>• <strong>理解 DFA</strong>：掌握确定性有限自动机的基本原理和工作机制，为理解 AC 自动机奠定基础。</p><p>• <strong>掌握 Trie 树与失败指针</strong>：深入了解 Trie 树的构建与失败指针的设置，理解 AC 自动机如何高效地进行多模式匹配。</p><p>• <strong>应用最佳实践</strong>：通过优化敏感词列表、合理设置失败指针、并发处理、定期更新敏感词库等最佳实践，充分发挥 AC 自动机的优势。</p><p>希望这篇文章能帮助您更全面地理解 <strong>AC 自动机</strong> 的演变过程及其在敏感词识别中的应用。如果您有任何疑问或需要进一步的技术支持，欢迎随时与我们交流！</p><p>在接下来的开发中，我们将继续优化谛听的功能，支持更多数据源和高级特性，让谛听真正成为敏感词识别领域的“神兽”！</p><p><strong>PS</strong>：敏感词们，谛听正在快速成长，你们准备好了吗？😎</p>`,108)]))}const d=i(t,[["render",h]]);export{o as __pageData,d as default};
